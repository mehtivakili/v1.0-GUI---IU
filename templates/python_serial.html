<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Serial Monitor</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #121212;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }
        .top-container {
            width: 100%;
            background-color: #1e1e1e;
            padding: 10px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 1;
        }
        .top-container h1 {
            color: #00b300;
            margin: 0;
        }
        .back-button {
            position: absolute;
            left: 20px;
            background: linear-gradient(90deg, #004d00, #00b300);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
            text-align: center;
            font-size: 16px;
        }
        .back-button:hover {
            background: linear-gradient(90deg, #00b300, #004d00);
        }

        .main-container {
            flex-grow: 1;
            width: 100%;
            display: flex;
            padding-top: 20px;
            overflow: hidden;
        }
        .side-container {
            width: 30%;
            background-color: #1e1e1e;
            padding: 20px;
            margin-left: 10px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
        }
        .serial-monitor {
            width: 70%;
            height: calc(100vh - 60px);
            overflow: auto;
            background-color: #1e1e1e;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            margin-left: 20px;
            padding: 20px;
        }
        select, button, input {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 5px;
            border: none;
            background: #333;
            color: white;
            width: 100%;
        }
        input[type="number"] {
            -moz-appearance: textfield;
        }
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .input-group {
            display: flex;
            gap: 10px;
        }
        button {
            background: linear-gradient(90deg, #004d00, #00b300);
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: linear-gradient(90deg, #00b300, #004d00);
        }
        .log {
            background: #121212;
            color: #00b300;
            height: calc(100% - 40px);
            overflow-y: auto;
            padding: 10px;
            border-radius: 10px;
            font-size: 12px;
        }

        #startStopButton.stop-recording {
            background-color: red;
            color: white;
            font-weight: bold;
            background: none; /* Remove gradient to apply solid color */
            /* background: linear-gradient(90deg, #ff0425, #4e011f); */
            background: #ff0425;
        }

        /* Hover state for the stop-recording button */
        #startStopButton.stop-recording:hover {
            /* background: linear-gradient(90deg, #4e011f, #ff0425); */
            background: radial-gradient(circle, #4e011f 0%, #ff0425 100%);
}

        #actionButtons {
            display: flex;
            justify-content: space-between;
            gap: 10px;
}

        #actionButtons button {
            flex: 1;
        }
        .plot-container {
            width: 100%;
            height: 50%;
        }
        .flex-container {
            display: flex;
            align-items: center; /* Center items vertically */
            gap: 10px; /* Space between final time and message */
        }

        @keyframes slow-flash {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.1;
            }
        }

        .flash {
            color: red;
            animation: slow-flash 2s infinite; /* Adjust duration as needed */
        }

        #timerDisplayContainer {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px;
            position: relative;}

        #timerDisplay {
            font-size: 2em;
            font-weight: bold;
            z-index: 1; /* Ensure it's above the ring */
        }

        @keyframes flashingRing {
            0% {
                box-shadow: 0 0 10px 2px rgba(255, 0, 0, 0.5);
            }
            50% {
                box-shadow: 0 0 10px 10px rgba(255, 0, 0, 1);
            }
            100% {
                box-shadow: 0 0 10px 2px rgba(255, 0, 0, 0.5);
            }
        }

        .flashing-ring {
            content: '';
            position: absolute;
            width: 100px; /* Adjust size as needed */
            height: 100px; /* Adjust size as needed */
            border-radius: 50%;
            animation: flashingRing 2s infinite; /* Adjust timing as needed */
        }

        

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- MathJax script for rendering LaTeX equations -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script>
        let isRecording = false;
        let isSerialPortOpen = false;
        const socket = io('http://localhost:3000',{transports:['websocket']});

        // Debug: Check connection status
        socket.on('connect', () => {
            console.log('Connected to server');
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from server');
        });

        socket.on('connect_error', (error) => {
            console.error('Connection error:', error);
        });
        let TioData = [];
        let accelX = [], accelY = [], accelZ = [];
        let gyroX = [], gyroY = [], gyroZ = [];

        // socket.on('sensor_data', function(data){
        //     console.log('aaa',data)
        // })
        contor = 0
        socket.on('sensor_data', function(data) {
            const { Tio, accel, gyro } = data;
            contor += 1;
            console.log('Received data:', Tio, accel, gyro); // Debug statement
            console.log(contor)
            TioData.push(Tio);
            accelX.push(accel[0]);
            accelY.push(accel[1]);
            accelZ.push(accel[2]);
            gyroX.push(gyro[0]);
            gyroY.push(gyro[1]);
            gyroZ.push(gyro[2]);

            Plotly.update('accelPlot', {
                x: [TioData],
                y: [accelX, accelY, accelZ]
            });

            Plotly.update('gyroPlot', {
                x: [TioData],
                y: [gyroX, gyroY, gyroZ]
            });

            // Limit the number of points to avoid performance issues
            if (TioData.length > 100) {
                TioData.shift();
                accelX.shift();
                accelY.shift();
                accelZ.shift();
                gyroX.shift();
                gyroY.shift();
                gyroZ.shift();
            }
        });

        function clearPlots() {
            TioData = [];
            accelX = [];
            accelY = [];
            accelZ = [];
            gyroX = [];
            gyroY = [];
            gyroZ = [];

            Plotly.update('accelPlot', {
                x: [[]],
                y: [[], [], []]
            });

            Plotly.update('gyroPlot', {
                x: [[]],
                y: [[], [], []]
            });
        }

        function generateDefaultRecordingName() {
            const now = new Date();
            const year = now.getFullYear().toString().slice(-2); // YY
            const month = String(now.getMonth() + 1).padStart(2, '0'); // MM
            const day = String(now.getDate()).padStart(2, '0'); // DD
            const hours = String(now.getHours()).padStart(2, '0'); // HH
            const minutes = String(now.getMinutes()).padStart(2, '0'); // MM
            return `${year}${month}${day}${hours}${minutes}`;
        }


        async function getPorts() {
            const response = await fetch('/get_ports');
            const ports = await response.json();
            const portSelect = document.getElementById('port');
            portSelect.innerHTML = '';
            ports.forEach(port => {
                const option = document.createElement('option');
                option.value = port.device;
                option.text = `${port.device} - ${port.description}`;
                portSelect.appendChild(option);
            });
        }

        async function openSerial() {
            const configSerial = document.getElementById('configSerial')

            const port = document.getElementById('port').value;
            const baudrate = document.getElementById('baudrate').value;
            // const isBinary = document.getElementById('binaryCheckbox').checked;
            const formData = new FormData();
            formData.append('port', port);
            formData.append('baudrate', baudrate);
            // formData.append('is_binary', isBinary);

            const response = await fetch('/open_serial', {
                method: 'POST',
                body: formData
            });
            const result = await response.json();
            if (result.status === 'success') {
                isSerialPortOpen = true; // Update flag
                configSerial.style.display = 'none'
                // alert('Serial port opened successfully');
            } else {
                alert(`Error: ${result.message}`);
            }
        }

        let timerInterval;

function calculateFinalTime() {
    const initiationStaticInterval = parseFloat(document.getElementById('initiationStaticInterval').value);
    const turnCounts = parseFloat(document.getElementById('turnCounts').value);
    const T_wait = parseFloat(document.getElementById('T_wait').value);
    
    const finalTime = initiationStaticInterval + (turnCounts * T_wait);
    document.getElementById('finalTimeDisplay').textContent = `Total Time: ${finalTime} seconds`;

    return finalTime;
}

function startTimer(duration) {
    let timer = 0;
    const display = document.getElementById('timerDisplay');
    const timerContainer = document.getElementById('timerDisplayContainer');
    display.style.display = 'block';
    display.textContent = timer;

    const initiationStaticInterval = parseFloat(document.getElementById('initiationStaticInterval').value);
    const turnCounts = parseFloat(document.getElementById('turnCounts').value);
    const T_wait = parseFloat(document.getElementById('T_wait').value);
    
    let turnMessageShown = false;
        // Add the flashing ring class
        timerContainer.classList.add('flashing-ring');


    timerInterval = setInterval(() => {
        timer++;
        display.textContent = timer;

        if (timer >= initiationStaticInterval && !turnMessageShown) {
            showMessage("Turn the device");
            turnMessageShown = true;
        } else if (turnMessageShown && (timer - initiationStaticInterval) % T_wait === 0 && (timer - initiationStaticInterval) / T_wait <= turnCounts - 1) {
            showMessage("Turn the device");
        }

        if (timer >= duration) {
            clearInterval(timerInterval);
            display.style.display = 'none';
            isRecording = false
            showActionButtons();
            timerContainer.classList.remove('flashing-ring'); // Remove the flashing ring class
        }
    }, 1000); // Update every second
}


function resetToStartRecordingState() {
    resetTime()
    const startStopButton = document.getElementById('startStopButton');
    startStopButton.textContent = 'Start Recording';
    startStopButton.classList.remove('stop-recording');
    startStopButton.style.display = 'flex'; // Ensure it's displayed
    startStopButton.style.justifyContent = 'center'; // Center the text
    startStopButton.style.alignItems = 'center'; // Center the text

    const actionButtons = document.getElementById('actionButtons');
    actionButtons.style.display = 'none';
    
}


function showActionButtons() {
    const startStopButton = document.getElementById('startStopButton');
    startStopButton.style.display = 'none';

    const actionButtons = document.getElementById('actionButtons');
    actionButtons.style.display = 'flex';
}

// function showMessage(message) {
//     const messageElement = document.createElement('div');
//     messageElement.textContent = message;
//     messageElement.className = 'flash';
//     document.body.appendChild(messageElement);

//     setTimeout(() => {
//         document.body.removeChild(messageElement);
//     }, 2000); // Adjust the time the message stays visible
// }

function showMessage() {
    const messageElement = document.getElementById('flashMessage');
    messageElement.style.display = 'block';

    setTimeout(() => {
        messageElement.style.display = 'none';
    }, 2000); // Adjust the time the message stays visible
}



        async function toggleRecording() {
            // clearPlots();
            // console.log(isRecording)
            resetTime();
            const timerContainer = document.getElementById('timerDisplayContainer');

                const startStopButton = document.getElementById('startStopButton');
            if(isSerialPortOpen === false) {
                alert('Please open the serial port first.');
                return; 
            }
            if (isRecording) {
            // Stop Recording Logic
            console.log("send stop req")
            const response = await fetch('/stop_recording', {
                method: 'GET'
            });
            if (response.ok) {
                // alert('Recording stopped');
                // clearPlot();
                console.log("did work")
                stopRecording();
                resetToStartRecordingState();
                // Add the flashing ring class
                timerContainer.classList.remove('flashing-ring'); // Remove the flashing ring class

            } else {
                alert('Error stopping recording');
            }
            return;
            }

            const recordingName = document.getElementById('recordingName').value;
            if (!recordingName) {
                alert('Please enter a recording name');
                return;
            }
            const finalTime = calculateFinalTime(); // Calculate the final time
            const fileName = document.getElementById('recordingName').value;
            // const offsetValue = calculateFinalTime(); // Calculate the final time
            // const Timer = document.getElementById('Timer').value;
            const formData = new FormData();
            formData.append('offset', finalTime);
            formData.append('recordingName', fileName);
            // formData.append('Timer', Timer);

            const response = await fetch('/start_recording', {
                method: 'POST',
                body: formData
            });
            const result = await response.json();
            if (result.status === 'success') {
                document.getElementById('recordingName').value = fileName; // Display the recording name as file name
                startTimer(finalTime); // Start the timer when recording starts
                console.log('hehehe')
                // alert('Recording started successfully');
                startStopButton.textContent = 'Stop Recording';
                startStopButton.classList.add('stop-recording');
                isRecording = true;
            } else {
                alert(`Error: ${result.message}`);
            }
         }

         function stopRecording() {
            resetTime()
            clearInterval(timerInterval); // Stop the timer interval
            clearPlots(); // Clear the plots
            isRecording = false; // Reset the recording state
            const display = document.getElementById('timerDisplay');
            display.style.display = 'none'; // Hide the timer display
            // display.style.visibility = 'hidden'
            display.textContent = 0;
            const startStopButton = document.getElementById('startStopButton');
            startStopButton.textContent = 'Start Recording';
            startStopButton.classList.remove('stop-recording');
            console.log("Stopped recording, state reset");
        }

        function stopTimer() {
            clearInterval(timerInterval); // Stop the timer interval
            const display = document.getElementById('timerDisplay');
            display.style.display = 'none'; // Hide the timer display
            // display.style.visibility = 'hidden'
            display.textContent = '0'; // Reset the timer display to 0
        }

        // function clearPlots() {
        //     // Clear the plots logic here
        //     Plotly.purge('accelPlot'); // Replace 'accelPlot' with your plot ID
        //     Plotly.purge('gyroPlot'); // Replace 'gyroPlot' with your plot ID
        // }

        async function resetTime() {
            const resetValue = 0
            const formData = new FormData();
            formData.append('offset', resetValue);
            clearPlots();
            const response = await fetch('/start_recording', {
                method: 'POST',
                body: formData
            })
            const result = await response.json();
            if (result.status === 'success') {
                // alert('Recording reset successfully');
            } else {
                alert(`Error: ${result.message}`);
            }
            
        }

        async function plotThis() {
            const recordingName = document.getElementById('recordingName').value;
            const response = await fetch(`/plot_data?recordingName=${recordingName}`);
            if (response.ok) {
                alert('Plotting started');
            } else {
                alert('Error plotting data');
            }
        }

        function goBack() {
            // window.location.href = '/python_serial';
            resetToStartRecordingState()
            // stopRecording()
        }

        async function calibrate() {
            // alert('Calibrate button clicked');
            if (isRecording) {
            // Stop Recording Logic
            console.log("Calibration started")
            const response = await fetch('/calibrate', {
                method: 'GET'
            });
            if (response.ok) {
                // alert('Recording stopped');
                // clearPlot();
                console.log("did calib")
                // stopRecording();
                // resetToStartRecordingState();
                // // Add the flashing ring class
                timerContainer.classList.remove('flashing-ring'); // Remove the flashing ring class

            } else {
                alert('Error stopping calib');
            }        
        }
    }

        async function closeSerial() {
            const response = await fetch('/close_serial', {
                method: 'POST'
            });
            const result = await response.json();
            if (result.status === 'success') {
                console.log('Serial port closed successfully');
            } else {
                console.error(`Error: ${result.message}`);
            }
        }

        function clearPlotAndStartRecording() {
            clearPlots();
            startRecording();
        }


        window.onload = getPorts;

        window.addEventListener('beforeunload', function() {
            closeSerial();
        });

        window.addEventListener('pagehide', function() {
            closeSerial();
        });

        document.addEventListener('DOMContentLoaded', function() {
            const recordingNameInput = document.getElementById('recordingName');
            recordingNameInput.placeholder = generateDefaultRecordingName();
           
            resetTime();

            // Update the final time in real-time as the user inputs values
            document.getElementById('initiationStaticInterval').addEventListener('input', calculateFinalTime);
            document.getElementById('turnCounts').addEventListener('input', calculateFinalTime);
            document.getElementById('T_wait').addEventListener('input', calculateFinalTime);

            // Initial calculation of final time
            calculateFinalTime();
            const accelLayout = {
                title: 'Acceleration Data',
                xaxis: { title: 'Time (Tio)' },
                yaxis: { title: 'Acceleration' }
            };
            const gyroLayout = {
                title: 'Gyroscope Data',
                xaxis: { title: 'Time (Tio)' },
                yaxis: { title: 'Gyroscope' }
            };
            Plotly.newPlot('accelPlot', [
                { x: [], y: [], mode: 'lines', name: 'Accel X' },
                { x: [], y: [], mode: 'lines', name: 'Accel Y' },
                { x: [], y: [], mode: 'lines', name: 'Accel Z' }
            ], accelLayout);
            Plotly.newPlot('gyroPlot', [
                { x: [], y: [], mode: 'lines', name: 'Gyro X' },
                { x: [], y: [], mode: 'lines', name: 'Gyro Y' },
                { x: [], y: [], mode: 'lines', name: 'Gyro Z' }
            ], gyroLayout);
        });
    </script>
</head>
<body>
    <div class="top-container">
        <button class="back-button" onclick="window.location.href='/'">Back to Home</button>
        <h1>Serial Monitor</h1>
    </div>
    <div class="main-container">
        <div class="side-container">
            <div id="configSerial">
                <h2>Select Serial Port</h2>
                <form onsubmit="event.preventDefault(); openSerial();">
                    <div class="input-group">
                        <select id="port" name="port" required></select>
                        <input type="number" id="baudrate" name="baudrate" placeholder="Baud Rate" value="115200" required>

                    </div>

                <!-- <label for="binaryCheckbox">Binary Mode</label>
                    <input type="checkbox" id="binaryCheckbox" name="binaryCheckbox" checked> -->
                    <button onclick="clearPlots()" type="submit">Open Serial Port</button>

                </form>
            </div>

            <div>
                <div class="input-group">
                    <label for="recordingName" aria-placeholder="please enter the file name">File Name</label>
                    <input type="text" id="recordingName" name="fileName" placeholder="please enter the file name" required>
                </div>
            </div>

            <div class="input-group">
                <label for="initiationStaticInterval">Initiation Static Interval</label>
                <input type="number" id="initiationStaticInterval" name="initiationStaticInterval" placeholder="50" value="50" required>
                <small>Recommended: 50 seconds</small>
            </div>
            <div class="input-group">
                <label for="turnCounts">Turn Counts</label>
                <input type="number" id="turnCounts" name="turnCounts" placeholder="40" value="40" required>
                <small>Recommended: 36 to 50 turns</small>
            </div>
            <div class="input-group">
                <label for="T_wait">T_wait</label>
                <input type="number" id="T_wait" name="T_wait" placeholder="4" value="4" required>
                <small>Recommended: 1 to 4 seconds</small>
            </div>
            <div style="display: flex; flex-direction: row; gap: 60px;">
                <p id="finalTimeDisplay">Final Time: 0 seconds</p>
                <div id="timerDisplayContainer">
                    <div id="timerDisplay" style="display: none; font-size: 20px; color: white; margin-top: 10px;"></div>
                </div>               
                <!-- <p id="timerDisplay" style="display: none; font-size: 20px; color: white; margin-top: 10px;"></p>     -->
            </div>
            <p id="flashMessage" class="flash" style="display: none;">Turn the device</p>

            <!-- LaTeX formatted equation -->
            <p id="latexEquation">Total time = Initiation Static Interval + Turn Counts * T_wait</p>
            <script>
                document.getElementById('latexEquation').innerHTML = '\\(\\text{Total time} = \\text{Initiation Static Interval} + \\text{Turn Counts} \\times T_{\\text{wait}}\\)';
                MathJax.typesetPromise(); // Render the LaTeX equation
            </script>
            <style>
                #latexEquation {
                    font-size: 12px; /* Adjust this value as needed */
                }
            </style>
            <div class="input-group">
                <button id="startStopButton" onclick="toggleRecording()">Start Recording</button>
            </div>
            <div class="input-group" id="actionButtons" style="display: none;">
                <button id="backButton" onclick="goBack()">Back</button>
                <button id="plotButton" onclick="plotThis()">Plot This</button>
                <button id="calibrateButton" onclick="calibrate()">Calibrate</button>
            </div>

            
            <!-- <button onclick="clearPlotAndStartRecording()">Start Recording</button> -->
        </div>
        <div class="serial-monitor">
            <div class="plot-container" id="accelPlot"></div>
            <div class="plot-container" id="gyroPlot"></div>
            <div class="log" id="log">
                <!-- Serial log will appear here -->
            </div>
        </div>
    </div>
</body>
</html>
